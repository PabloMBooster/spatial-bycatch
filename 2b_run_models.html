<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Brian Stock" />


<title>Step 2: Run spatiotemporal models for fisheries bycatch prediction</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Step 2: Run spatiotemporal models for fisheries bycatch prediction</h1>
<h4 class="author"><em>Brian Stock</em></h4>
<h4 class="date"><em>Sept 29, 2017</em></h4>



<p>This vignette demonstrates how we ran the spatiotemporal models in:</p>
<blockquote>
<p>Stock BC, Ward EJ, Eguchi T, Jannot JE, Thorson JT, Feist BE, and Semmens BX. “Random forests outperform other species distribution models for spatiotemporal fisheries bycatch prediction.”</p>
</blockquote>
<p>We assume you either 1) have already seen <a href="https://rawgit.com/brianstock/spatial-bycatch/master/2a_process_survey.html"><code>2a_process_survey</code></a>, or 2) are not interested in how the data were processed/prepared. Either way, from this point we continue by using the saved output of <code>2a_process_survey</code> (<code>wcann_processed.RData</code>).</p>
<p><em>Note:</em> Because the fisheries observer datasets we used are confidential (<a href="https://www.nwfsc.noaa.gov/research/divisions/fram/observation/data_collection/manuals/2017%20WCGOP%20Training%20Manual%20Final%20website%20copy.pdf">WCGOP</a>, <a href="http://www.nmfs.noaa.gov/pr/interactions/fkwtrt/meeting1/handouts/observer_manual.pdf">HILL</a>), here we perform the same analyses using the publically available <a href="https://www.nwfsc.noaa.gov/research/divisions/fram/groundfish/bottom_trawl.cfm">West Coast Groundfish Trawl Survey</a>.</p>
<div id="load-data-and-packages" class="section level3">
<h3>Load data and packages</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># load the data from 2a_process_survey</span>
<span class="kw">load</span>(<span class="st">&quot;/home/brian/Dropbox/bycatch/manuscript/spatial-bycatch/wcann_processed.RData&quot;</span>)
<span class="kw">head</span>(dat)</code></pre></div>
<pre><code>##          HAUL_ID YEAR       DATE      LAT       LON    DEPTH   TOTAL DBRK
## 359  2.00303e+11 2003 2003-06-24 46.09611 -124.7761 564.9317 123.176 0.00
## 6671 2.00303e+11 2003 2003-06-24 46.02472 -124.7389 310.0056 304.980 1.81
## 6925 2.00303e+11 2003 2003-06-24 46.15667 -124.5156 140.7280 501.270 1.35
## 6926 2.00303e+11 2003 2003-06-24 46.50389 -124.7325 606.3237  98.910 0.00
## 7216 2.00303e+11 2003 2003-06-24 46.75500 -124.5428 107.4615 714.960 0.00
## 182  2.00303e+11 2003 2003-06-25 47.60194 -124.8156 106.0853 573.350 0.10
##      PHLB YEYE      DAY YEYE_01 PHLB_01 DBRK_01         SST      fath
## 359     0    0 -43.1275       0       0       0 -0.01410765 308.90841
## 6671    0    0 -43.1275       0       0       1  0.04703642 169.51312
## 6925   18    0 -43.1275       0       1       1 -0.06884963  76.95101
## 6926    0    0 -43.1275       0       0       0 -0.38681021 331.54183
## 7216    0    0 -43.1275       0       0       0 -0.61593420  58.76066
## 182     0    0 -42.1275       0       0       1 -1.53736698  58.00815
##      fath_categ id MONTH inRCA bin   logDEPTH        sst       sst2
## 359        250+  1   Jun     0   0  0.7985194  0.8565284 0.73364093
## 6671    150-200  2   Jun     1   4  0.1984049  0.9176725 0.84212280
## 6925     75-100  3   Jun     1   4 -0.5913565  0.8017864 0.64286150
## 6926       250+  4   Jun     0   0  0.8692286  0.4838259 0.23408747
## 7216      50-60  5   Jun     1   4 -0.8610528  0.2547019 0.06487305
## 182       50-60  6   Jun     1   4 -0.8739419 -0.6667309 0.44453010
##       logDEPTH2
## 359  0.63763326
## 6671 0.03936452
## 6925 0.34970247
## 6926 0.75555833
## 7216 0.74141188
## 182  0.76377450</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(randomForest)
<span class="kw">library</span>(ROCR)
<span class="kw">library</span>(DMwR)
<span class="kw">library</span>(caret)
<span class="kw">library</span>(mgcv)
<span class="kw">library</span>(INLA)
<span class="co"># INLA:::inla.dynload.workaround() # if old dependencies</span></code></pre></div>
</div>
<div id="setup-stratified-10-fold-cross-validation" class="section level3">
<h3>Setup stratified 10-fold cross validation</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Use caret package to do stratified k-fold cross validation</span>
k =<span class="st"> </span><span class="dv">10</span>
ind &lt;-<span class="st"> </span><span class="kw">list</span>()
species.bin &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;DBRK&quot;</span>,<span class="st">&quot;PHLB&quot;</span>,<span class="st">&quot;YEYE&quot;</span>)
for(sp in <span class="dv">1</span>:<span class="kw">length</span>(species.bin)){
  sp.col &lt;-<span class="st"> </span><span class="kw">paste0</span>(species.bin[sp],<span class="st">&quot;_01&quot;</span>)
  ind[[sp]] &lt;-<span class="st"> </span><span class="kw">createFolds</span>(dat[,sp.col], <span class="dt">k=</span>k)
}</code></pre></div>
</div>
<div id="functions-to-calculate-model-performance" class="section level3">
<h3>Functions to calculate model performance</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">calc_AUC &lt;-<span class="st"> </span>function(pred, obs){
  obs &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">as.character</span>(obs))
  predict =<span class="st"> </span><span class="kw">prediction</span>(<span class="kw">as.vector</span>(pred), obs)
  AUC &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="kw">unlist</span>(<span class="kw">slot</span>(<span class="kw">performance</span>(predict,<span class="st">&quot;auc&quot;</span>),<span class="st">&quot;y.values&quot;</span>)),<span class="dv">3</span>)
  <span class="kw">return</span>(AUC)
}
calc_RMSE &lt;-<span class="st"> </span>function(pred, obs){
  RMSE &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="kw">sqrt</span>(<span class="kw">mean</span>((pred-obs)^<span class="dv">2</span>)),<span class="dv">3</span>)
  <span class="kw">return</span>(RMSE)
}</code></pre></div>
</div>
<div id="model-descriptions-and-functions" class="section level3">
<h3>Model descriptions and functions</h3>
<p><span class="math inline">\(Y\)</span> is the response:</p>
<ul>
<li>0/1 for the binomial component of delta model</li>
<li>catch (kg) for the positive component of delta model</li>
</ul>
<p><span class="math inline">\(Y_j\)</span> denotes response in year <span class="math inline">\(j\)</span> for models that fit spatial terms by year.</p>
<ol style="list-style-type: decimal">
<li>GLM</li>
</ol>
<blockquote>
<p><span class="math inline">\(Y\)</span> ~ logDEPTH + logDEPTH<span class="math inline">\(^2\)</span> + sst + sst<span class="math inline">\(^2\)</span> + inRCA + DAY + YEAR</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit_GLM &lt;-<span class="st"> </span>function(dat, sp.ind, covar, modeltype, fit.id, test.id){
  btime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
  dat$z &lt;-<span class="st"> </span>dat[,sp.ind]
    formula.glm =<span class="st"> </span><span class="kw">as.formula</span>(<span class="kw">paste0</span>(<span class="st">&quot;z ~ -1 + YEAR + &quot;</span>, <span class="kw">paste</span>(covar, <span class="dt">collapse=</span><span class="st">&quot; + &quot;</span>)))
  if(modeltype==<span class="st">&quot;binomial&quot;</span>) fit &lt;-<span class="st"> </span><span class="kw">gam</span>(formula.glm, <span class="dt">family=</span><span class="st">&quot;binomial&quot;</span>, <span class="dt">data=</span>dat[fit.id,])
    if(modeltype==<span class="st">&quot;positive&quot;</span>) fit &lt;-<span class="st"> </span><span class="kw">gam</span>(formula.glm, <span class="dt">family=</span><span class="kw">Gamma</span>(<span class="dt">link=</span><span class="st">&quot;log&quot;</span>), <span class="dt">data=</span>dat[fit.id,])
    
    <span class="co"># calculate and return performance</span>
    obs &lt;-<span class="st"> </span>dat[test.id, sp.ind] <span class="co"># observations at test locations</span>
    pred &lt;-<span class="st"> </span><span class="kw">predict</span>(fit, <span class="dt">newdata=</span>dat[test.id,], <span class="dt">type=</span><span class="st">'response'</span>)
    etime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
    rtime &lt;-<span class="st"> </span>etime -<span class="st"> </span>btime
    if(modeltype==<span class="st">&quot;binomial&quot;</span>){
      AUC &lt;-<span class="st"> </span><span class="kw">calc_AUC</span>(pred, obs)
      <span class="kw">return</span>(<span class="kw">list</span>(AUC, fit, pred, obs, rtime))
    }
    if(modeltype==<span class="st">&quot;positive&quot;</span>){
      RMSE &lt;-<span class="st"> </span><span class="kw">calc_RMSE</span>(pred, obs)
      <span class="kw">return</span>(<span class="kw">list</span>(RMSE, fit, pred, obs, rtime))
    }
}</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>GAM CONSTANT</li>
</ol>
<blockquote>
<p><span class="math inline">\(Y\)</span> ~ logDEPTH + logDEPTH<span class="math inline">\(^2\)</span> + sst + sst<span class="math inline">\(^2\)</span> + inRCA + DAY + YEAR + s(LON, LAT)</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit_GAM_CONSTANT &lt;-<span class="st"> </span>function(dat, sp.ind, covar, modeltype, fit.id, test.id){
  btime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
  dat$z &lt;-<span class="st"> </span>dat[,sp.ind]
    formula.gam.const =<span class="st"> </span><span class="kw">as.formula</span>(<span class="kw">paste0</span>(<span class="st">&quot;z ~ -1 + YEAR + s(LON,LAT,k=100) + &quot;</span>,
                                          <span class="kw">paste</span>(covar, <span class="dt">collapse=</span><span class="st">&quot; + &quot;</span>)))
  if(modeltype==<span class="st">&quot;binomial&quot;</span>) fit &lt;-<span class="st"> </span><span class="kw">gam</span>(formula.gam.const, <span class="dt">family=</span><span class="st">&quot;binomial&quot;</span>, <span class="dt">data=</span>dat[fit.id,])
    if(modeltype==<span class="st">&quot;positive&quot;</span>) fit &lt;-<span class="st"> </span><span class="kw">gam</span>(formula.gam.const, <span class="dt">family=</span><span class="kw">Gamma</span>(<span class="dt">link=</span><span class="st">&quot;log&quot;</span>), <span class="dt">data=</span>dat[fit.id,])

    <span class="co"># calculate and return performance</span>
    obs &lt;-<span class="st"> </span>dat[test.id, sp.ind] <span class="co"># observations at test locations</span>
    pred &lt;-<span class="st"> </span><span class="kw">predict</span>(fit, <span class="dt">newdata=</span>dat[test.id,], <span class="dt">type=</span><span class="st">'response'</span>)
    etime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
    rtime &lt;-<span class="st"> </span>etime -<span class="st"> </span>btime
    if(modeltype==<span class="st">&quot;binomial&quot;</span>){
      AUC &lt;-<span class="st"> </span><span class="kw">calc_AUC</span>(pred, obs)
      <span class="kw">return</span>(<span class="kw">list</span>(AUC, fit, pred, obs, rtime))
    }
    if(modeltype==<span class="st">&quot;positive&quot;</span>){
      RMSE &lt;-<span class="st"> </span><span class="kw">calc_RMSE</span>(pred, obs)
      <span class="kw">return</span>(<span class="kw">list</span>(RMSE, fit, pred, obs, rtime))
    }
}</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>GAM IID</li>
</ol>
<blockquote>
<p><span class="math inline">\(Y_j\)</span> ~ logDEPTH + logDEPTH<span class="math inline">\(^2\)</span> + sst + sst<span class="math inline">\(^2\)</span> + inRCA + DAY + s(LON, LAT)<span class="math inline">\(_j\)</span></p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit_GAM_IID &lt;-<span class="st"> </span>function(dat, sp.ind, covar, modeltype, fit.id, test.id){
  btime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
  dat$z &lt;-<span class="st"> </span>dat[,sp.ind]
    formula.gam.iid =<span class="st"> </span><span class="kw">as.formula</span>(<span class="kw">paste0</span>(<span class="st">&quot;z ~ -1 + s(LON,LAT,k=100,by=YEAR) + &quot;</span>,  <span class="kw">paste</span>(covar, <span class="dt">collapse=</span><span class="st">&quot; + &quot;</span>)))
  if(modeltype==<span class="st">&quot;binomial&quot;</span>) fit &lt;-<span class="st"> </span><span class="kw">gam</span>(formula.gam.iid, <span class="dt">family=</span><span class="st">&quot;binomial&quot;</span>, <span class="dt">data=</span>dat[fit.id,])
    if(modeltype==<span class="st">&quot;positive&quot;</span>) fit &lt;-<span class="st"> </span><span class="kw">gam</span>(formula.gam.iid, <span class="dt">family=</span><span class="kw">Gamma</span>(<span class="dt">link=</span><span class="st">&quot;log&quot;</span>), <span class="dt">data=</span>dat[fit.id,])
    
    <span class="co"># calculate and return performance</span>
    obs &lt;-<span class="st"> </span>dat[test.id, sp.ind] <span class="co"># observations at test locations</span>
    pred &lt;-<span class="st"> </span><span class="kw">predict</span>(fit, <span class="dt">newdata=</span>dat[test.id,], <span class="dt">type=</span><span class="st">'response'</span>)
    etime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
    rtime &lt;-<span class="st"> </span>etime -<span class="st"> </span>btime
    if(modeltype==<span class="st">&quot;binomial&quot;</span>){
      AUC &lt;-<span class="st"> </span><span class="kw">calc_AUC</span>(pred, obs)
      <span class="kw">return</span>(<span class="kw">list</span>(AUC, fit, pred, obs, rtime))
    }
    if(modeltype==<span class="st">&quot;positive&quot;</span>){
      RMSE &lt;-<span class="st"> </span><span class="kw">calc_RMSE</span>(pred, obs)
      <span class="kw">return</span>(<span class="kw">list</span>(RMSE, fit, pred, obs, rtime))
    }
}</code></pre></div>
<ol start="4" style="list-style-type: decimal">
<li>GMRF CONSTANT</li>
</ol>
<blockquote>
<p><span class="math inline">\(Y\)</span> ~ logDEPTH + logDEPTH<span class="math inline">\(^2\)</span> + sst + sst<span class="math inline">\(^2\)</span> + inRCA + DAY + YEAR + <span class="math inline">\(MVN(0, Q^{-1})\)</span></p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># See below:</span>
<span class="co">#   one GMRF function with input option to select CONSTANT vs. EXCHANGEABLE</span></code></pre></div>
<ol start="5" style="list-style-type: decimal">
<li>GMRF EXCHANGEABLE</li>
</ol>
<blockquote>
<p><span class="math inline">\(Y_j\)</span> ~ logDEPTH + logDEPTH<span class="math inline">\(^2\)</span> + sst + sst<span class="math inline">\(^2\)</span> + inRCA + DAY + YEAR + <span class="math inline">\(MVN(0, Q_j^{-1})\)</span></p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit_GMRF &lt;-<span class="st"> </span>function(dat, sp.ind, covar, modeltype, modeltype.GMRF, fit.id, test.id){
  btime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
  <span class="co"># response needs to be numeric, not factor</span>
  dat[,sp.ind] &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">as.character</span>(dat[,sp.ind]))
  <span class="co"># inRCA needs to be numeric, not factor</span>
  dat$inRCA &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">as.character</span>(dat$inRCA))
  
  <span class="co"># turn 2012 to NA so YEAR=2012 will be intercept, other years will be offsets</span>
  if(modeltype.GMRF==<span class="st">&quot;CONSTANT&quot;</span>){
    dat$YEAR &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">as.character</span>(dat$YEAR))
    dat$YEAR[<span class="kw">which</span>(dat$YEAR==<span class="dv">2012</span>)] &lt;-<span class="st"> </span><span class="ot">NA</span>
    dat$YEAR &lt;-<span class="st"> </span><span class="kw">as.factor</span>(dat$YEAR)
  }
  <span class="co"># record keeping</span>
  n.years &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">levels</span>(dat$YEAR))
  yr.labs &lt;-<span class="st"> </span><span class="kw">levels</span>(dat$YEAR)
  <span class="kw">levels</span>(dat$YEAR) &lt;-<span class="st"> </span><span class="dv">1</span>:n.years
  n.sites &lt;-<span class="st"> </span><span class="kw">dim</span>(dat)[<span class="dv">1</span>]
  
  <span class="co"># CONSTANT includes offset terms for each year</span>
  <span class="co"># EXCHANGEABLE includes separate GMRF for each year, so don't want YEAR terms</span>
  if(modeltype.GMRF==<span class="st">&quot;CONSTANT&quot;</span>) covar =<span class="st"> </span><span class="kw">c</span>(covar,<span class="st">&quot;YEAR&quot;</span>)
  n.covar &lt;-<span class="st"> </span><span class="kw">length</span>(covar)
  
  <span class="co"># difference between binomial and positive delta model components</span>
  if(modeltype==<span class="st">&quot;binomial&quot;</span>) family.inla =<span class="st"> &quot;binomial&quot;</span> 
  if(modeltype==<span class="st">&quot;positive&quot;</span>) family.inla =<span class="st"> &quot;gamma&quot;</span> 
  n.fit &lt;-<span class="st"> </span><span class="kw">length</span>(fit.id)
  n.test &lt;-<span class="st"> </span><span class="kw">length</span>(test.id)
  
  <span class="co"># Set up mesh</span>
  coords.fit =<span class="st"> </span><span class="kw">cbind</span>(dat$LON[fit.id], dat$LAT[fit.id])
  coords.test =<span class="st"> </span><span class="kw">cbind</span>(dat$LON[test.id], dat$LAT[test.id])
  bnd =<span class="st"> </span><span class="kw">inla.nonconvex.hull</span>(coords.fit, <span class="dt">convex=</span>-<span class="fl">0.05</span>, <span class="dt">concave=</span>-<span class="fl">0.2</span>)
  mesh1 =<span class="st"> </span><span class="kw">inla.mesh.2d</span>(<span class="dt">loc=</span>coords.fit, <span class="dt">boundary=</span>bnd, <span class="dt">offset=</span><span class="kw">c</span>(-<span class="fl">0.01</span>,-<span class="fl">0.03</span>), 
                       <span class="dt">cutoff=</span><span class="fl">0.3</span>, <span class="dt">max.edge=</span><span class="kw">c</span>(.<span class="dv">6</span>,<span class="fl">1.3</span>))
  spde =<span class="st"> </span><span class="kw">inla.spde2.matern</span>(mesh1, <span class="dt">alpha=</span><span class="dv">2</span>) <span class="co"># alpha = matern parameter</span>
  
  <span class="co"># Make index for spatial field</span>
  <span class="co">#   CONSTANT: fit one spatial field</span>
    <span class="co">#   EXCHANGEABLE: fit different spatial fields for each year</span>
  if(modeltype.GMRF==<span class="st">&quot;CONSTANT&quot;</span>) iset &lt;-<span class="st"> </span><span class="kw">inla.spde.make.index</span>(<span class="st">&quot;i&quot;</span>, <span class="dt">n.spde=</span>mesh1$n)
    if(modeltype.GMRF==<span class="st">&quot;EXCHANGEABLE&quot;</span>) iset &lt;-<span class="st"> </span><span class="kw">inla.spde.make.index</span>(<span class="st">'i'</span>, <span class="dt">n.spde=</span>spde$n.spde,
                                                                    <span class="dt">n.group=</span>n.years)

  <span class="co"># Make A matrix (projects from mesh nodes to data locations)</span>
  if(modeltype.GMRF==<span class="st">&quot;CONSTANT&quot;</span>){
      A &lt;-<span class="st"> </span><span class="kw">inla.spde.make.A</span>(<span class="dt">mesh=</span>mesh1, <span class="dt">loc=</span>coords.fit)
      A.test &lt;-<span class="st"> </span><span class="kw">inla.spde.make.A</span>(<span class="dt">mesh=</span>mesh1, <span class="dt">loc=</span>coords.test)
  }
  if(modeltype.GMRF==<span class="st">&quot;EXCHANGEABLE&quot;</span>){
      A &lt;-<span class="st"> </span><span class="kw">inla.spde.make.A</span>(<span class="dt">mesh=</span>mesh1, <span class="dt">loc=</span>coords.fit, 
                            <span class="dt">group=</span><span class="kw">as.numeric</span>(dat$YEAR)[fit.id])
      A.test &lt;-<span class="st"> </span><span class="kw">inla.spde.make.A</span>(<span class="dt">mesh=</span>mesh1, <span class="dt">loc=</span>coords.test, 
                                 <span class="dt">group=</span><span class="kw">as.numeric</span>(dat$YEAR)[test.id])
  }
  A.list =<span class="st"> </span><span class="kw">list</span>(); A.list[[<span class="dv">1</span>]] =<span class="st"> </span>A;
  for(i in <span class="dv">1</span>:n.covar) A.list[[i<span class="dv">+1</span>]] &lt;-<span class="st"> </span><span class="dv">1</span>;
  A.list.test =<span class="st"> </span><span class="kw">list</span>(); A.list.test[[<span class="dv">1</span>]] =<span class="st"> </span>A.test;
  for (i in <span class="dv">1</span>:n.covar) A.list.test[[i<span class="dv">+1</span>]] &lt;-<span class="st"> </span><span class="dv">1</span>;

  <span class="co"># Make list of covariates including 'iset', the GMRF</span>
  effect.list =<span class="st"> </span><span class="kw">list</span>(<span class="dt">i =</span> iset, 
                    <span class="dt">sst =</span> dat[fit.id,<span class="st">&quot;sst&quot;</span>], 
                    <span class="dt">sst2 =</span> dat[fit.id,<span class="st">&quot;sst2&quot;</span>], 
                    <span class="dt">logDEPTH =</span> dat[fit.id,<span class="st">&quot;logDEPTH&quot;</span>], 
                    <span class="dt">logDEPTH2 =</span> dat[fit.id,<span class="st">&quot;logDEPTH2&quot;</span>], 
                    <span class="dt">inRCA =</span> dat[fit.id,<span class="st">&quot;inRCA&quot;</span>], 
                    <span class="dt">DAY =</span> dat[fit.id,<span class="st">&quot;DAY&quot;</span>])
  effect.list.test =<span class="st"> </span><span class="kw">list</span>(<span class="dt">i =</span> iset, 
                    <span class="dt">sst =</span> dat[test.id,<span class="st">&quot;sst&quot;</span>], 
                    <span class="dt">sst2 =</span> dat[test.id,<span class="st">&quot;sst2&quot;</span>], 
                    <span class="dt">logDEPTH =</span> dat[test.id,<span class="st">&quot;logDEPTH&quot;</span>], 
                    <span class="dt">logDEPTH2 =</span> dat[test.id,<span class="st">&quot;logDEPTH2&quot;</span>], 
                    <span class="dt">inRCA =</span> dat[test.id,<span class="st">&quot;inRCA&quot;</span>], 
                    <span class="dt">DAY =</span> dat[test.id,<span class="st">&quot;DAY&quot;</span>])
  if(modeltype.GMRF==<span class="st">&quot;CONSTANT&quot;</span>){ <span class="co"># CONSTANT model has YEAR terms in it</span>
      effect.list$YEAR &lt;-<span class="st"> </span>dat[fit.id,<span class="st">&quot;YEAR&quot;</span>]
      effect.list.test$YEAR &lt;-<span class="st"> </span>dat[test.id,<span class="st">&quot;YEAR&quot;</span>]
  }
  
  <span class="co"># 'stack' data together</span>
  <span class="co"># sdat.fit: data for GMRF model to fit</span>
  sdat.fit &lt;-<span class="st"> </span><span class="kw">inla.stack</span>(<span class="dt">tag=</span><span class="st">'sdat.fit'</span>, <span class="dt">data=</span><span class="kw">list</span>(<span class="dt">z=</span>dat[fit.id, sp.ind]), 
                         <span class="dt">A=</span>A.list, <span class="dt">effects=</span>effect.list)
  <span class="co"># sdat.test: data for GMRF model to predict</span>
  <span class="co"># set z=NA to tell R-INLA to predict for these locations</span>
  sdat.test &lt;-<span class="st"> </span><span class="kw">inla.stack</span>(<span class="dt">tag=</span><span class="st">'sdat.test'</span>, <span class="dt">data=</span><span class="kw">list</span>(<span class="dt">z=</span><span class="kw">rep</span>(<span class="ot">NA</span>, n.test)), 
                          <span class="dt">A=</span>A.list.test, <span class="dt">effects=</span>effect.list.test)
  sdat.full &lt;-<span class="st"> </span><span class="kw">inla.stack</span>(sdat.fit, sdat.test)

  <span class="co"># Make INLA formula</span>
  if(modeltype.GMRF==<span class="st">&quot;CONSTANT&quot;</span>){
    formula.inla =<span class="st"> </span><span class="kw">as.formula</span>(<span class="kw">paste0</span>(<span class="st">&quot;z ~ -1 + &quot;</span>, 
            <span class="kw">paste</span>(covar, <span class="dt">collapse=</span><span class="st">&quot;+&quot;</span>),
            <span class="st">&quot;+ f(i, model=spde)&quot;</span>))} 
  if(modeltype.GMRF==<span class="st">&quot;EXCHANGEABLE&quot;</span>){
    formula.inla =<span class="st"> </span><span class="kw">as.formula</span>(<span class="kw">paste0</span>(<span class="st">&quot;z ~ -1 + &quot;</span>, 
            <span class="kw">paste</span>(covar, <span class="dt">collapse=</span><span class="st">&quot;+&quot;</span>), 
            <span class="st">&quot;+ f(i, model=spde, group=i.group, control.group=list(model='exchangeable'))&quot;</span>))}
  
  <span class="co"># Call INLA</span>
  <span class="co"># quick run to find posterior mode, using gaussian approximation and </span>
  <span class="co">#   empirical Bayes integration strategy over the hyperparameters</span>
  start.inla &lt;-<span class="st"> </span><span class="kw">inla</span>(formula.inla, <span class="dt">num.threads=</span><span class="dv">12</span>, <span class="dt">family =</span> family.inla,
                     <span class="dt">data =</span> <span class="kw">inla.stack.data</span>(sdat.full), 
                     <span class="dt">control.predictor =</span> <span class="kw">list</span>(<span class="dt">link=</span><span class="dv">1</span>, <span class="dt">compute=</span><span class="ot">FALSE</span>, <span class="dt">A=</span><span class="kw">inla.stack.A</span>(sdat.full)),
                     <span class="dt">verbose =</span> <span class="ot">TRUE</span>, <span class="dt">debug=</span><span class="ot">TRUE</span>, <span class="dt">keep=</span><span class="ot">FALSE</span>,
                     <span class="dt">control.inla =</span> <span class="kw">list</span>(<span class="dt">strategy=</span><span class="st">&quot;gaussian&quot;</span>, <span class="dt">int.strategy=</span><span class="st">&quot;eb&quot;</span>),
                     <span class="dt">control.compute =</span> <span class="kw">list</span>(<span class="dt">dic=</span><span class="ot">TRUE</span>, <span class="dt">cpo=</span><span class="ot">TRUE</span>), 
                     <span class="dt">control.fixed =</span> <span class="kw">list</span>(<span class="dt">expand.factor.strategy=</span><span class="st">'inla'</span>, <span class="dt">correlation.matrix=</span><span class="ot">TRUE</span>), 
                     <span class="dt">control.results=</span><span class="kw">list</span>(<span class="dt">return.marginals.random=</span><span class="ot">FALSE</span>,<span class="dt">return.marginals.predictor=</span><span class="ot">FALSE</span>))
  <span class="co"># longer run using more accurate approximation, uses posterior mode found in previous step</span>
  out.inla &lt;-<span class="st"> </span><span class="kw">inla</span>(formula.inla, <span class="dt">num.threads=</span><span class="dv">12</span>, <span class="dt">family =</span> family.inla, 
                   <span class="dt">data=</span><span class="kw">inla.stack.data</span>(sdat.full), 
                   <span class="dt">control.predictor=</span><span class="kw">list</span>(<span class="dt">link=</span><span class="dv">1</span>, <span class="dt">compute=</span><span class="ot">TRUE</span>, <span class="dt">A=</span><span class="kw">inla.stack.A</span>(sdat.full)), 
                   <span class="dt">verbose =</span> <span class="ot">TRUE</span>, <span class="dt">debug=</span><span class="ot">TRUE</span>, <span class="dt">keep=</span><span class="ot">FALSE</span>, 
                   <span class="dt">control.compute =</span> <span class="kw">list</span>(<span class="dt">dic=</span><span class="ot">TRUE</span>,<span class="dt">cpo=</span><span class="ot">TRUE</span>), 
                   <span class="dt">control.fixed =</span> <span class="kw">list</span>(<span class="dt">expand.factor.strategy=</span><span class="st">'inla'</span>,<span class="dt">correlation.matrix=</span><span class="ot">TRUE</span>), 
                   <span class="dt">control.mode =</span> <span class="kw">list</span>(<span class="dt">theta=</span>start.inla$mode$theta, <span class="dt">restart=</span><span class="ot">FALSE</span>), 
                   <span class="dt">control.results=</span><span class="kw">list</span>(<span class="dt">return.marginals.random=</span><span class="ot">FALSE</span>,<span class="dt">return.marginals.predictor=</span><span class="ot">FALSE</span>))
  
  etime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
    rtime &lt;-<span class="st"> </span>etime -<span class="st"> </span>btime
  
  <span class="co"># Calculate and return performance metrics on test data (binomial)</span>
  if(modeltype==<span class="st">&quot;binomial&quot;</span>){
    <span class="co"># Get predicted and observed</span>
    ind.pred &lt;-<span class="st"> </span><span class="kw">inla.stack.index</span>(sdat.full,<span class="st">'sdat.test'</span>)$data
    pred &lt;-<span class="st"> </span>out.inla$summary.fitted.values[ind.pred,<span class="st">&quot;mean&quot;</span>]
    obs &lt;-<span class="st"> </span>dat[test.id, sp.ind]
    AUC &lt;-<span class="st"> </span><span class="kw">calc_AUC</span>(pred, obs)
    <span class="co"># Return AUC and model objects</span>
    fit &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">&quot;AUC&quot;</span>=AUC,<span class="st">&quot;out.inla&quot;</span>=out.inla,<span class="st">&quot;pred&quot;</span>=pred,<span class="st">&quot;obs&quot;</span>=obs,<span class="st">&quot;rtime&quot;</span>=rtime,<span class="st">&quot;mesh1&quot;</span>=mesh1,
                <span class="st">&quot;iset&quot;</span>=iset,<span class="st">&quot;sdat.full&quot;</span>=sdat.full,<span class="st">&quot;test.id&quot;</span>=test.id,<span class="st">&quot;fit.id&quot;</span>=fit.id,
                <span class="st">&quot;n.test&quot;</span>=n.test,<span class="st">&quot;n.fit&quot;</span>=n.fit)
  }
  
  <span class="co"># Calculate and return performance metrics (positive)</span>
  if(modeltype==<span class="st">&quot;positive&quot;</span>){
    <span class="co"># Get predicted and observed</span>
    ind.pred &lt;-<span class="st"> </span><span class="kw">inla.stack.index</span>(sdat.full,<span class="st">'sdat.test'</span>)$data
    pred &lt;-<span class="st"> </span>out.inla$summary.fitted.values[ind.pred,<span class="st">&quot;mean&quot;</span>]
    obs &lt;-<span class="st"> </span>dat[test.id, sp.ind]
    RMSE &lt;-<span class="st"> </span><span class="kw">calc_RMSE</span>(pred, obs)
    <span class="co"># Return RMSE and model objects</span>
    fit &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">&quot;RMSE&quot;</span>=RMSE,<span class="st">&quot;out.inla&quot;</span>=out.inla,<span class="st">&quot;pred&quot;</span>=pred,<span class="st">&quot;obs&quot;</span>=obs,<span class="st">&quot;rtime&quot;</span>=rtime,
                <span class="st">&quot;mesh1&quot;</span>=mesh1,<span class="st">&quot;iset&quot;</span>=iset,<span class="st">&quot;sdat.full&quot;</span>=sdat.full,<span class="st">&quot;test.id&quot;</span>=test.id,
                <span class="st">&quot;fit.id&quot;</span>=fit.id,<span class="st">&quot;n.test&quot;</span>=n.test,<span class="st">&quot;n.fit&quot;</span>=n.fit)
  }
  <span class="kw">return</span>(fit)
}</code></pre></div>
<ol start="6" style="list-style-type: decimal">
<li>RF BASE</li>
<li>RF DOWN</li>
<li>RF SMOTE</li>
</ol>
<blockquote>
<p><span class="math inline">\(Y\)</span> ~ logDEPTH, sst, inRCA, DAY, YEAR, LAT, LON</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># RF BASE is the default randomForest function</span>
fit_RF_BASE &lt;-<span class="st"> </span>function(dat, sp.ind, covar, modeltype, fit.id, test.id){
  btime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
  <span class="co"># keep forest for prediction at test locations</span>
  fit &lt;-<span class="st"> </span><span class="kw">randomForest</span>(<span class="dt">x=</span>dat[fit.id, covar], <span class="dt">y=</span>dat[fit.id, sp.ind], 
                      <span class="dt">xtest=</span>dat[test.id, covar], <span class="dt">ytest=</span>dat[test.id, sp.ind],
                      <span class="dt">mtry=</span><span class="dv">3</span>, <span class="dt">ntree=</span><span class="dv">1000</span>, <span class="dt">importance=</span><span class="ot">FALSE</span>, <span class="dt">do.trace=</span><span class="dv">250</span>, <span class="dt">keep.forest=</span><span class="ot">TRUE</span>) 
    
    <span class="co"># calculate and return performance</span>
  etime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
  rtime &lt;-<span class="st"> </span>etime -<span class="st"> </span>btime
    obs &lt;-<span class="st"> </span>dat[test.id, sp.ind] <span class="co"># observations at test locations</span>
    if(modeltype==<span class="st">&quot;binomial&quot;</span>){
      pred &lt;-<span class="st"> </span><span class="kw">predict</span>(fit, <span class="dt">newdata=</span>dat[test.id,], <span class="dt">type=</span><span class="st">'prob'</span>)[,<span class="dv">2</span>]
      AUC &lt;-<span class="st"> </span><span class="kw">calc_AUC</span>(pred, obs)
      <span class="kw">return</span>(<span class="kw">list</span>(AUC, fit, pred, obs, rtime))
    }
    if(modeltype==<span class="st">&quot;positive&quot;</span>){
      pred &lt;-<span class="st"> </span><span class="kw">predict</span>(fit, <span class="dt">newdata=</span>dat[test.id,], <span class="dt">type=</span><span class="st">'response'</span>)
      RMSE &lt;-<span class="st"> </span><span class="kw">calc_RMSE</span>(pred, obs)
      <span class="kw">return</span>(<span class="kw">list</span>(RMSE, fit, pred, obs, rtime))
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># RF DOWN downsamples the majority class (binomial component only)</span>
<span class="co"># downsample = if classes are imbalanced, train RF using equal #s of 0s and 1s</span>
fit_RF_DOWN &lt;-<span class="st"> </span>function(dat, sp.ind, covar, fit.id, test.id){
  btime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
    <span class="co"># nmin &lt;- sum(dat[fit.id, sp.ind])-1 # number of minority class (assume 1s)</span>
    nmin &lt;-<span class="st"> </span><span class="kw">table</span>(dat[fit.id,sp.ind])[<span class="dv">2</span>]; <span class="kw">names</span>(nmin) &lt;-<span class="st"> </span><span class="ot">NULL</span>;
    prop1 &lt;-<span class="st"> </span>nmin/<span class="kw">length</span>(fit.id)
    prop0 &lt;-<span class="st"> </span><span class="dv">1</span>-prop1
    if(prop0 &lt;<span class="st"> </span>prop1) nmin &lt;-<span class="st"> </span><span class="kw">length</span>(fit.id) -<span class="st"> </span>nmin <span class="co"># if 0s are minority, use # of 0s</span>
  fit &lt;-<span class="st"> </span><span class="kw">randomForest</span>(<span class="dt">sampsize=</span><span class="kw">rep</span>(<span class="kw">round</span>(nmin/<span class="dv">6</span>),<span class="dv">2</span>), <span class="dt">x=</span>dat[fit.id, covar], 
                      <span class="dt">y=</span>dat[fit.id, sp.ind], <span class="dt">mtry=</span><span class="dv">3</span>, <span class="dt">ntree=</span><span class="dv">1000</span>, 
                      <span class="dt">importance=</span><span class="ot">FALSE</span>, <span class="dt">do.trace=</span><span class="dv">250</span>, <span class="dt">keep.forest=</span><span class="ot">TRUE</span>) 
  
    <span class="co"># calculate and return performance</span>
  etime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
  rtime &lt;-<span class="st"> </span>etime -<span class="st"> </span>btime
    obs &lt;-<span class="st"> </span>dat[test.id, sp.ind] <span class="co"># observations at test locations</span>
  pred &lt;-<span class="st"> </span><span class="kw">predict</span>(fit, <span class="dt">newdata=</span>dat[test.id,], <span class="dt">type=</span><span class="st">'prob'</span>)[,<span class="dv">2</span>]
  AUC &lt;-<span class="st"> </span><span class="kw">calc_AUC</span>(pred, obs)
  <span class="kw">return</span>(<span class="kw">list</span>(AUC, fit, pred, obs, rtime))
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># RF SMOTE is also designed to improve RF for imbalanced data (binomial component only)</span>
<span class="co"># SMOTE = Synthetic Minority Over-sampling Technique</span>
<span class="co">#   combines downsampling of majority class with oversampling of minority class</span>
<span class="co">#   creates synthetic minority class instances by generating random linear combinations</span>
fit_RF_SMOTE &lt;-<span class="st"> </span>function(dat, sp.ind, covar, fit.id, test.id){
  btime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
  prop &lt;-<span class="st"> </span><span class="kw">table</span>(dat[fit.id, sp.ind])[<span class="dv">2</span>] /<span class="st"> </span><span class="kw">length</span>(fit.id) <span class="co"># get percent minority class (1s)</span>
  p.over &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="dv">50</span>/prop) <span class="co"># percent to oversample to get to 50%</span>
  p.under &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="dv">100</span>/(<span class="dv">1</span>-prop)) <span class="co"># percent to undersample to get to 50%</span>
  X &lt;-<span class="st"> </span><span class="kw">cbind</span>(dat[fit.id, covar], dat[fit.id, sp.ind])
  <span class="kw">names</span>(X) &lt;-<span class="st"> </span><span class="kw">c</span>(covar, <span class="st">&quot;z&quot;</span>)
  formula.rf &lt;-<span class="st"> </span><span class="kw">formula</span>(<span class="kw">paste0</span>(<span class="st">&quot;z ~ &quot;</span>, <span class="kw">paste0</span>(covar, <span class="dt">collapse=</span><span class="st">&quot; + &quot;</span>)))
  X.SMOTE &lt;-<span class="st"> </span><span class="kw">SMOTE</span>(formula.rf, <span class="dt">data=</span>X, <span class="dt">k=</span><span class="dv">5</span>, <span class="dt">perc.over=</span>p.over, <span class="dt">perc.under=</span>p.under)
  <span class="co"># table(X.SMOTE$z) # check now we roughly have class balance</span>
  fit &lt;-<span class="st"> </span><span class="kw">randomForest</span>(<span class="dt">x=</span>X.SMOTE[,covar], <span class="dt">y=</span>X.SMOTE[,<span class="st">&quot;z&quot;</span>], <span class="dt">mtry=</span><span class="dv">3</span>, <span class="dt">ntree=</span><span class="dv">1000</span>, <span class="dt">importance=</span><span class="ot">FALSE</span>, <span class="dt">do.trace=</span><span class="dv">250</span>, <span class="dt">keep.forest=</span><span class="ot">TRUE</span>)

  <span class="co"># calculate and return performance</span>
  etime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
  rtime &lt;-<span class="st"> </span>etime -<span class="st"> </span>btime
    obs &lt;-<span class="st"> </span>dat[test.id, sp.ind] <span class="co"># observations at test locations</span>
  <span class="co"># pred &lt;- predict(fit, newdata=dat[test.id, covar], type='prob', predict.all=TRUE)</span>
  pred &lt;-<span class="st"> </span><span class="kw">predict</span>(fit, <span class="dt">newdata=</span>dat[test.id, covar], <span class="dt">type=</span><span class="st">'prob'</span>)[,<span class="dv">2</span>]
  AUC &lt;-<span class="st"> </span><span class="kw">calc_AUC</span>(pred, obs)
  <span class="kw">return</span>(<span class="kw">list</span>(AUC, fit, pred, obs, rtime))
}</code></pre></div>
</div>
<div id="run-the-models" class="section level3">
<h3>Run the models</h3>
<p><strong>Warning: this took 40 hours on a 12-core 32gb RAM machine</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Set up binomial model storage</span>
species.bin &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;DBRK&quot;</span>,<span class="st">&quot;PHLB&quot;</span>,<span class="st">&quot;YEYE&quot;</span>)
n.species.bin &lt;-<span class="st"> </span><span class="kw">length</span>(species.bin)
models.bin &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;GLM&quot;</span>,<span class="st">&quot;GAM CONSTANT&quot;</span>,<span class="st">&quot;GAM IID&quot;</span>,<span class="st">&quot;GMRF CONSTANT&quot;</span>,<span class="st">&quot;GMRF EXCHANGEABLE&quot;</span>,<span class="st">&quot;RF BASE&quot;</span>,<span class="st">&quot;RF DOWN&quot;</span>,<span class="st">&quot;RF SMOTE&quot;</span>)
n.models.bin &lt;-<span class="st"> </span><span class="kw">length</span>(models.bin)
AUC &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>,<span class="dt">dim=</span><span class="kw">c</span>(n.species.bin, n.models.bin, k))
fits.bin &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, n.species.bin)

<span class="co"># Set up positive model storage</span>
species.pos &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;DBRK&quot;</span>,<span class="st">&quot;PHLB&quot;</span>)
n.species.pos &lt;-<span class="st"> </span><span class="kw">length</span>(species.pos)
models.pos &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;GLM&quot;</span>,<span class="st">&quot;GAM CONSTANT&quot;</span>,<span class="st">&quot;GAM IID&quot;</span>,<span class="st">&quot;GMRF CONSTANT&quot;</span>,<span class="st">&quot;GMRF EXCHANGEABLE&quot;</span>,<span class="st">&quot;RF BASE&quot;</span>)
n.models.pos &lt;-<span class="st"> </span><span class="kw">length</span>(models.pos)
RMSE &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>,<span class="dt">dim=</span><span class="kw">c</span>(n.species.pos, n.models.pos, k))
fits.pos &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, n.species.pos)

<span class="co"># Use same environmental covariates for all models</span>
covar &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;logDEPTH&quot;</span>, <span class="st">&quot;logDEPTH2&quot;</span>, <span class="st">&quot;sst&quot;</span>, <span class="st">&quot;sst2&quot;</span>, <span class="st">&quot;inRCA&quot;</span>, <span class="st">&quot;DAY&quot;</span>)
<span class="co"># Random forest includes lat/lon as covariates instead of spatial structures</span>
rf.covar &lt;-<span class="st"> </span><span class="kw">c</span>(covar, <span class="st">&quot;YEAR&quot;</span>, <span class="st">&quot;LAT&quot;</span>, <span class="st">&quot;LON&quot;</span>)

<span class="co"># Run binomial models</span>
for(sp in <span class="dv">1</span>:n.species.bin){ <span class="co"># for each species</span>
  modeltype &lt;-<span class="st"> &quot;binomial&quot;</span>
  sp.lab &lt;-<span class="st"> </span>species.bin[sp]
  sp.col &lt;-<span class="st"> </span><span class="kw">paste0</span>(sp.lab,<span class="st">&quot;_01&quot;</span>)
  sp.ind &lt;-<span class="st"> </span><span class="kw">match</span>(sp.col, <span class="kw">names</span>(dat))
  fits.bin[[sp]] &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, n.models.bin)
  
  for(f in <span class="dv">1</span>:k){ <span class="co"># for each fold</span>
    test.id &lt;-<span class="st"> </span>ind[[sp]][[f]] <span class="co"># get test rows for this species and fold (10% of data)</span>
    fit.id &lt;-<span class="st"> </span>dat[-test.id,<span class="st">&quot;id&quot;</span>] <span class="co"># get rows to fit models (90% of data)</span>
    
    <span class="co"># Fit GLM</span>
    fits.bin[[sp]][[<span class="dv">1</span>]] &lt;-<span class="st"> </span><span class="kw">fit_GLM</span>(dat, sp.ind, covar, modeltype, fit.id, test.id)
    <span class="co"># Fit GAM CONSTANT</span>
    fits.bin[[sp]][[<span class="dv">2</span>]] &lt;-<span class="st"> </span><span class="kw">fit_GAM_CONSTANT</span>(dat, sp.ind, covar, modeltype, fit.id, test.id)
    <span class="co"># Fit GAM IID</span>
    fits.bin[[sp]][[<span class="dv">3</span>]] &lt;-<span class="st"> </span><span class="kw">fit_GAM_IID</span>(dat, sp.ind, covar, modeltype, fit.id, test.id)
    <span class="co"># Fit GMRF CONSTANT</span>
    fits.bin[[sp]][[<span class="dv">4</span>]] &lt;-<span class="st"> </span><span class="kw">fit_GMRF</span>(dat, sp.ind, covar, modeltype, 
                                    <span class="dt">modeltype.GMRF=</span><span class="st">&quot;CONSTANT&quot;</span>, fit.id, test.id)
    <span class="co"># Fit GMRF EXCHANGEABLE</span>
    fits.bin[[sp]][[<span class="dv">5</span>]] &lt;-<span class="st"> </span><span class="kw">fit_GMRF</span>(dat, sp.ind, covar, modeltype, 
                                    <span class="dt">modeltype.GMRF=</span><span class="st">&quot;EXCHANGEABLE&quot;</span>, fit.id, test.id)
    <span class="co"># Fit RF BASE</span>
    fits.bin[[sp]][[<span class="dv">6</span>]] &lt;-<span class="st"> </span><span class="kw">fit_RF_BASE</span>(dat, sp.ind, rf.covar, modeltype, fit.id, test.id)
    <span class="co"># Fit RF DOWN</span>
    fits.bin[[sp]][[<span class="dv">7</span>]] &lt;-<span class="st"> </span><span class="kw">fit_RF_DOWN</span>(dat, sp.ind, rf.covar, fit.id, test.id)    
    <span class="co"># Fit RF SMOTE</span>
    fits.bin[[sp]][[<span class="dv">8</span>]] &lt;-<span class="st"> </span><span class="kw">fit_RF_SMOTE</span>(dat, sp.ind, rf.covar, fit.id, test.id)
  }
}

<span class="co"># Run positive models</span>
for(sp in <span class="dv">1</span>:n.species.pos){ <span class="co"># for each species</span>
  modeltype &lt;-<span class="st"> &quot;positive&quot;</span>  
  sp.lab &lt;-<span class="st"> </span>species.pos[sp]
  sp.col &lt;-<span class="st"> </span>sp.lab
  sp.ind &lt;-<span class="st"> </span><span class="kw">match</span>(sp.col, <span class="kw">names</span>(dat))
  fits.pos[[sp]] &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, n.models.pos)
  
  for(f in <span class="dv">1</span>:k){ <span class="co"># for each fold</span>
    test.id &lt;-<span class="st"> </span>ind[[sp]][[f]] <span class="co"># get test rows for this species and fold (10% of data)</span>
    fit.id &lt;-<span class="st"> </span>dat[-test.id,<span class="st">&quot;id&quot;</span>] <span class="co"># get rows to fit models (90% of data)</span>
    
    <span class="co"># Only want to fit non-zero points in the positive model</span>
    pos.fit &lt;-<span class="st"> </span><span class="kw">which</span>(dat[fit.id, sp.ind] &gt;<span class="st"> </span><span class="dv">0</span>)
    fit.id &lt;-<span class="st"> </span>fit.id[pos.fit]
    pos.test &lt;-<span class="st"> </span><span class="kw">which</span>(dat[test.id, sp.ind] &gt;<span class="st"> </span><span class="dv">0</span>)
    test.id &lt;-<span class="st"> </span>test.id[pos.test]    
    
    <span class="co"># Fit GLM</span>
    fits.pos[[sp]][[<span class="dv">1</span>]] &lt;-<span class="st"> </span><span class="kw">fit_GLM</span>(dat, sp.ind, covar, modeltype, fit.id, test.id)
    <span class="co"># Fit GAM CONSTANT</span>
    fits.pos[[sp]][[<span class="dv">2</span>]] &lt;-<span class="st"> </span><span class="kw">fit_GAM_CONSTANT</span>(dat, sp.ind, covar, modeltype, fit.id, test.id)
    
    <span class="co"># GAM IID crashes for PHLB</span>
    if(sp==<span class="dv">1</span>) fits.pos[[sp]][[f]][[<span class="dv">3</span>]] &lt;-<span class="st"> </span><span class="kw">fit_GAM_IID</span>(dat, sp.ind, covar, modeltype, fit.id, test.id)
    if(sp==<span class="dv">2</span>) fits.pos[[sp]][[f]][[<span class="dv">3</span>]] &lt;-<span class="st"> </span><span class="ot">NULL</span>
    
    <span class="co"># Fit GMRF CONSTANT</span>
    fits.pos[[sp]][[<span class="dv">4</span>]] &lt;-<span class="st"> </span><span class="kw">fit_GMRF</span>(dat, sp.ind, covar, modeltype, 
                                    <span class="dt">modeltype.GMRF=</span><span class="st">&quot;CONSTANT&quot;</span>, fit.id, test.id)
    <span class="co"># Fit GMRF EXCHANGEABLE</span>
    fits.pos[[sp]][[<span class="dv">5</span>]] &lt;-<span class="st"> </span><span class="kw">fit_GMRF</span>(dat, sp.ind, covar, modeltype, 
                                    <span class="dt">modeltype.GMRF=</span><span class="st">&quot;EXCHANGEABLE&quot;</span>, fit.id, test.id)
    <span class="co"># Fit RF BASE</span>
    fits.pos[[sp]][[<span class="dv">6</span>]] &lt;-<span class="st"> </span><span class="kw">fit_RF_BASE</span>(dat, sp.ind, rf.covar, modeltype, fit.id, test.id)
  }
}</code></pre></div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
